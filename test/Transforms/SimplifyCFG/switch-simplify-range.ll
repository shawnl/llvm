; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes='simplify-cfg<switch-to-lookup>' < %s | FileCheck %s
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

attributes #0 = { "no-jump-tables"="false" }

define i64 @switch_common_right_bits(i8 %a) #0  {
; CHECK-LABEL: @switch_common_right_bits(
; CHECK-NEXT:  Entry:
; CHECK-NEXT:    [[SWITCH_TABLEIDX_ZEXT:%.*]] = zext i8 [[A:%.*]] to i9
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [256 x i64], [256 x i64]* @switch.table.switch_common_right_bits, i32 0, i9 [[SWITCH_TABLEIDX_ZEXT]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i64, i64* [[SWITCH_GEP]]
; CHECK-NEXT:    ret i64 [[SWITCH_LOAD]]
;
Entry:
  switch i8 %a, label %SwitchElse [
  i8 253, label %SwitchProng
  i8 255, label %SwitchProng1
  i8 1, label %SwitchProng2
  i8 3, label %SwitchProng3
  ]
SwitchElse:                                       ; preds = %Entry
  ret i64 10
SwitchProng:                                      ; preds = %Entry
  ret i64 6
SwitchProng1:                                     ; preds = %Entry
  ret i64 3
SwitchProng2:                                     ; preds = %Entry
  ret i64 3
SwitchProng3:                                     ; preds = %Entry
  ret i64 3
}

define i64 @switch_ctz(i16 %a) optsize #0  {
; CHECK-LABEL: @switch_ctz(
; CHECK-NEXT:  Entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call i16 @llvm.cttz.i16(i16 [[A:%.*]], i1 false)
; CHECK-NEXT:    [[TMP1:%.*]] = sub i16 [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i16 [[TMP1]], 8
; CHECK-NEXT:    br i1 [[TMP2]], label [[SWITCH_LOOKUP:%.*]], label [[SWITCHELSE:%.*]]
; CHECK:       switch.lookup:
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [8 x i64], [8 x i64]* @switch.table.switch_ctz, i32 0, i16 [[TMP1]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i64, i64* [[SWITCH_GEP]]
; CHECK-NEXT:    ret i64 [[SWITCH_LOAD]]
; CHECK:       SwitchElse:
; CHECK-NEXT:    ret i64 10
;
Entry:
  switch i16 %a, label %SwitchElse [
  i16 2, label %SwitchProng
  i16 4, label %SwitchProng1
  i16 8, label %SwitchProng2
  i16 1, label %SwitchProng3
  i16 64, label %SwitchProng6
  i16 128, label %SwitchProng7
  i16 16, label %SwitchProng5
  i16 32, label %SwitchProng4
  ]
SwitchElse:                                       ; preds = %Entry
  ret i64 10
SwitchProng:                                      ; preds = %Entry
  ret i64 6
SwitchProng1:                                     ; preds = %Entry
  ret i64 3
SwitchProng2:                                     ; preds = %Entry
  ret i64 35
SwitchProng3:                                     ; preds = %Entry
  ret i64 31
SwitchProng4:                                     ; preds = %Entry
  ret i64 53
SwitchProng5:                                     ; preds = %Entry
  ret i64 51
SwitchProng6:                                     ; preds = %Entry
  ret i64 41
SwitchProng7:                                     ; preds = %Entry
  ret i64 34
}

define i64 @switch_clz(i8 %a) optsize #0  {
; CHECK-LABEL: @switch_clz(
; CHECK-NEXT:  Entry:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i8 [[A:%.*]], 0
; CHECK-NEXT:    [[TMP1:%.*]] = call i8 @llvm.fshr.i8(i8 [[TMP0]], i8 [[TMP0]], i8 5)
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i8 [[TMP1]], 5
; CHECK-NEXT:    br i1 [[TMP2]], label [[SWITCH_LOOKUP:%.*]], label [[SWITCHPRONG2:%.*]]
; CHECK:       switch.lookup:
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [5 x i64], [5 x i64]* @switch.table.switch_clz, i32 0, i8 [[TMP1]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i64, i64* [[SWITCH_GEP]]
; CHECK-NEXT:    ret i64 [[SWITCH_LOAD]]
; CHECK:       SwitchProng2:
; CHECK-NEXT:    ret i64 12
;
Entry:
  switch i8 %a, label %SwitchElse [
  i8 128, label %SwitchProng2
  i8 64, label %SwitchProng3
  i8 32, label %SwitchProng6
  i8 0, label %SwitchProng5
  ]
SwitchProng2:                                     ; preds = %Entry
  ret i64 35
SwitchProng3:                                     ; preds = %Entry
  ret i64 31
SwitchProng6:                                     ; preds = %Entry
  ret i64 41
SwitchProng5:                                     ; preds = %Entry
  ret i64 40
SwitchElse:                                     ; preds = %Entry
  ret i64 12
}

;Must check that the default was filled in at index 0 as happened here:
;@switch.table.switch_not_normalized_to_start_at_zero = private unnamed_addr constant [6 x i16] [i16 10, i16 7, i16 3, i16 1, i16 6, i16 8], align 2
define i16 @switch_not_normalized_to_start_at_zero(i8 %a) #0  {
; CHECK-LABEL: @switch_not_normalized_to_start_at_zero(
; CHECK-NEXT:  Entry:
; CHECK-NEXT:    [[SWITCH_TABLEIDX_ZEXT:%.*]] = zext i8 [[A:%.*]] to i9
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [256 x i16], [256 x i16]* @switch.table.switch_not_normalized_to_start_at_zero, i32 0, i9 [[SWITCH_TABLEIDX_ZEXT]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i16, i16* [[SWITCH_GEP]]
; CHECK-NEXT:    ret i16 [[SWITCH_LOAD]]
;
Entry:
  switch i8 %a, label %SwitchElse [
  i8 4, label %SwitchProng
  i8 2, label %SwitchProng1
  i8 1, label %SwitchProng2
  i8 3, label %SwitchProng3
  i8 5, label %SwitchProng4
  ]
SwitchElse:                                       ; preds = %Entry
  ret i16 10
SwitchProng:                                      ; preds = %Entry
  ret i16 6
SwitchProng1:                                     ; preds = %Entry
  ret i16 3
SwitchProng2:                                     ; preds = %Entry
  ret i16 7
SwitchProng3:                                     ; preds = %Entry
  ret i16 1
SwitchProng4:                                     ; preds = %Entry
  ret i16 8
}
